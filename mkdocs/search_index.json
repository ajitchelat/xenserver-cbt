{
    "docs": [
        {
            "location": "/", 
            "text": "Citrix XenServer Changed Block Tracking Guide\n\n\nChanged block tracking provides a set of features and APIs that enable you to develop fast and space-efficient incremental backup solutions for XenServer.\n\n\nChanged block tracking is available only to customers with XenServer Enterprise Edition.\nIf a customer without Enterprise Edition attempts to use an incremental backup solution for XenServer that uses changed block tracking, they are prevented from enabling changed block tracking on new VDIs.\nHowever, if the customer has existing VDIs with changed block tracking enabled, they can still perform other changed block tracking actions on these VDIs.\n\n\nHow changed block tracking works\n\n\nWhen changed block tracking is enabled for a virtual disk image (VDI), any blocks that are changed in that VDI are recorded in a log file.\nEvery time the VDI is snapshotted, this log file can be used to identify the blocks that have changed since the VDI was last snapshotted.\nThis provides the capability to backup only those blocks that have changed.\n\n\nAfter the changed blocks have been exported, the full VDI snapshots can now be changed into metadata-only snapshots by destroying the data associated with them and leaving only the changed block information.\nThese metadata only snapshots are linked both to the preceding metadata-only snapshot and to the following metadata-only snapshot.\nThis provides a chain of metadata that records the full history of changes to this VDI since changed block tracking was enabled.\n\n\nThe changed block tracking feature also takes advantage of network block device (NBD) capabilities to perform the export of data from the changed blocks.\n\n\nBenefits of changed block tracking\n\n\nUnlike some other incremental backup solutions, changed block tracking does not require that the customer keep a snapshot of the last known good state of a VDI available on the host or a storage repository (SR) to compare the current state to.\nThe customer needs less disk space because, instead of handling and storing large VDIs, with changed block tracking they instead can choose to store space-efficient metadata-only snapshot files.\n\n\nChanged block tracking also saves the customer time as well as space.\nOther backup solutions export a snapshot of the whole VDI every single time the VDI is backed up.\nThis is a time-consuming process and the customer has to pay that time cost every time they take a backup.\nWith changed block tracking enabled, the first back up exports a snapshot of the whole VDI.\nHowever, subsequent backups only export the blocks in the VDI that have changed since the previous backup.\nThis decreases the time required to export the backup in proportion to the percentage of blocks that have changed.\n\n\nFor example, it can take around 10 hours to export a backup of a full 1 TB VDI.\nIf, after a week, 5% of the blocks in that VDI have changed, exporting the backup takes 5% of the time - 30 minutes.\nA backup taken after a day has even fewer changed blocks and takes even less time to export.\n\n\nThe savings in time and space that changed block tracking provides makes it a preferable backup solution for customers using XenServer.\nThe simple API that XenServer exposes makes it easy for you to develop an incremental backup solution that delivers these benefits to the end user.\nYou can use this API through the language-agnostic remote procedure calls (RPCs) or take advantage of the language bindings provided for C, C#, Java, Python and PowerShell.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#citrix-xenserver-changed-block-tracking-guide", 
            "text": "Changed block tracking provides a set of features and APIs that enable you to develop fast and space-efficient incremental backup solutions for XenServer.  Changed block tracking is available only to customers with XenServer Enterprise Edition.\nIf a customer without Enterprise Edition attempts to use an incremental backup solution for XenServer that uses changed block tracking, they are prevented from enabling changed block tracking on new VDIs.\nHowever, if the customer has existing VDIs with changed block tracking enabled, they can still perform other changed block tracking actions on these VDIs.", 
            "title": "Citrix XenServer Changed Block Tracking Guide"
        }, 
        {
            "location": "/#how-changed-block-tracking-works", 
            "text": "When changed block tracking is enabled for a virtual disk image (VDI), any blocks that are changed in that VDI are recorded in a log file.\nEvery time the VDI is snapshotted, this log file can be used to identify the blocks that have changed since the VDI was last snapshotted.\nThis provides the capability to backup only those blocks that have changed.  After the changed blocks have been exported, the full VDI snapshots can now be changed into metadata-only snapshots by destroying the data associated with them and leaving only the changed block information.\nThese metadata only snapshots are linked both to the preceding metadata-only snapshot and to the following metadata-only snapshot.\nThis provides a chain of metadata that records the full history of changes to this VDI since changed block tracking was enabled.  The changed block tracking feature also takes advantage of network block device (NBD) capabilities to perform the export of data from the changed blocks.", 
            "title": "How changed block tracking works"
        }, 
        {
            "location": "/#benefits-of-changed-block-tracking", 
            "text": "Unlike some other incremental backup solutions, changed block tracking does not require that the customer keep a snapshot of the last known good state of a VDI available on the host or a storage repository (SR) to compare the current state to.\nThe customer needs less disk space because, instead of handling and storing large VDIs, with changed block tracking they instead can choose to store space-efficient metadata-only snapshot files.  Changed block tracking also saves the customer time as well as space.\nOther backup solutions export a snapshot of the whole VDI every single time the VDI is backed up.\nThis is a time-consuming process and the customer has to pay that time cost every time they take a backup.\nWith changed block tracking enabled, the first back up exports a snapshot of the whole VDI.\nHowever, subsequent backups only export the blocks in the VDI that have changed since the previous backup.\nThis decreases the time required to export the backup in proportion to the percentage of blocks that have changed.  For example, it can take around 10 hours to export a backup of a full 1 TB VDI.\nIf, after a week, 5% of the blocks in that VDI have changed, exporting the backup takes 5% of the time - 30 minutes.\nA backup taken after a day has even fewer changed blocks and takes even less time to export.  The savings in time and space that changed block tracking provides makes it a preferable backup solution for customers using XenServer.\nThe simple API that XenServer exposes makes it easy for you to develop an incremental backup solution that delivers these benefits to the end user.\nYou can use this API through the language-agnostic remote procedure calls (RPCs) or take advantage of the language bindings provided for C, C#, Java, Python and PowerShell.", 
            "title": "Benefits of changed block tracking"
        }, 
        {
            "location": "/getting-started/", 
            "text": "Getting started using changed block tracking\n\n\nThis section steps through the process of using changed block tracking to create incremental backups.\n\n\nBefore getting started with changed block tracking, we recommend that you read the Citrix XenServer Software Developer Kit Guide.\nThis document contains information to help you become familiar with developing for XenServer.\n\n\nThe examples provided in these steps use the Python binding for the Management API.\n\n\n\n\n\n\nFor more information about the individual RPC calls, see the \nCitrix XenServer Management API\n\n\n\n\n\n\nFor more detailed information about individual steps in this process, see the following chapters.\n\n\n\n\n\n\nFull Python examples are provided on \nGitHub\n.\n\n\nThe NBD connection examples provided in these steps use the Linux nbd-client.\nHowever, you can use any NBD client that supports the \"fixed newstyle\" version of the NBD protocol.\nFor more information, see \nthe NBD protocol documentation\n.\n\n\n\n\nNote\n\n\nIf you are using the Linux upstream NBD client, a minimum version of 3.15 is required to support TLS.\n\n\n\n\nPrerequisites\n\n\nBefore you start, set up or implement an NBD client at the backup location that supports the \"fixed newstyle\" version of the NBD protocol.\nFor more information, see \nExporting the changed blocks using an NBD client\n.\n\n\nEnable NBD connections on your network.\nFor more information, see \nEnabling NBD connections on XenServer\n.\n\n\nProcedure\n\n\nThis procedure is broken down into three sections:\n\n\n\n\n\n\nSetting up changed block tracking\n\n    Perform the steps in this section once, when you start using changed\n    block tracking, to enable the changed block tracking capability and\n    export a base snapshot that the incremental, changed block exported\n    data is compared to.\n\n\n\n\n\n\nTaking incremental backups\n\n    Perform the steps in this section every time you want to take an\n    incremental back up of the changed blocks in a VDI.\n\n\n\n\n\n\nRestoring a VDI from exported changed block data\n\n    Perform the steps in this section if you want to use your backed up\n    data to restore a VDI to an earlier state.\n\n\n\n\n\n\nSetting up changed block tracking\n\n\nBefore you can take incremental backups of a VDI using changed block tracking, you must first enable changed block tracking on the VDI and export a base snapshot.\nTo set up changed block tracking for a VDI, complete the following steps\n\n\n\n\n\n\nUse the Management API to establish a XenAPI session on the\n    XenServer host:\n\n\n```python\nimport XenAPI\nimport shutil\nimport urllib3\nimport requests\n\n\nsession = XenAPI.xapi_local()\nsession.xenapi.login_with_password(\"\n\", \"\n\", \"\n\", \"\n\")\n```\n\n\n\n\n\n\nOptional\n: If you intend to create a new VM and new VDIs to restore your backed up data to, you must also export your VM metadata.\n    Ensure that you export a copy of the VM metadata any time your VM properties change.\n    This can be done by using HTTPS or by using the command line.\n\n\n```python\nsession_id = session._session\nurl = (\"https://%s/export_metadata?session_id=%s\nuuid=%s\"\n        \"\nexport_snapshots=false\"\n        % (\n, session_id, \n))\n\n\nwith requests.Session() as session:\n    urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)\n    request = session.get(url, verify=False, stream=True)\n    with open(\n, 'wb') as filehandle:\n        shutil.copyfileobj(request.raw, filehandle)\n    request.raise_for_status()\n```\n\n\nWhere \nexport_path\n is the location to save the VM metadata to.\n\n\nThe export URL includes the parameter \nexport_snapshots=false\n.\nThis parameter ensures that the snapshot history is not included in the VM metadata backup.\nThe VM metadata is used to create a new VM and this snapshot history does not apply to the new VM.\n\n\nIf you intend to use your backed up data only to restore existing VDIs and VMs, you can skip this step.\n\n\n\n\n\n\nGet a reference for the VDI you want to snapshot:\n\n\npython\nvdi_ref = session.xenapi.VDI.get_by_uuid(\"\nvdi_uuid\n\")\n\n\n\n\n\n\nEnable changed block tracking for the VDI:\n\n\npython\nsession.xenapi.VDI.enable_cbt(\nvdi_ref\n)\n\n\nFor more information, see \nUsing changed block tracking with a virtual disk image\n.\n\n\n\n\n\n\nTake a snapshot of the VDI:\n\n\npython\nbase_snapshot_vdi_ref = session.xenapi.VDI.snapshot(\nvdi_ref\n)\n\n\nThis VDI snapshot is the base snapshot.\n\n\n\n\n\n\nExport the base VDI snapshot to the backup location. This can be done by using HTTPS or by using the command line.\n\n\nFor example, at the xe command line run:\n\n\npython\nxe vdi-export uuid=\nbase-snapshot-vdi-uuid\n filename=\nname of export\n\n\nOr, in Python, you can use the following code:\n\n\npython\nsession_id = session._session\nurl = ('https://%s/export_raw_vdi?session_id=%s\nvdi=%s\nformat=raw'\n       % (\nxs_host\n, session_id, \nbase_snapshot_vdi_uuid\n))\nwith requests.Session() as http_session:\n    urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)\n    request = http_session.get(url, verify=False, stream=True)\n    with open(\nexport_path\n, 'wb') as filehandle:\n        shutil.copyfileobj(request.raw, filehandle)\n    request.raise_for_status()\n\n\nWhere \nexport_path\n is the location you want to write the exported VDI to.\n\n\n\n\n\n\nOptional: For each VDI snapshot, delete the snapshot data, but retain the metadata:\n\n\npython\nsession.xenapi.VDI.data_destroy(\nbase_snapshot_vdi_ref\n)\n\n\nThis frees up space on the host or SR.\n\n\nFor more information, see \nDeleting VDI snapshot data and retaining the snapshot metadata\n.\n\n\n\n\n\n\nTaking incremental backups\n\n\nAfter taking the initial VDI snapshot and exporting all the data, the following steps can be repeated every time an incremental backup is taken of the VDI.\nThese incremental backups export only the blocks that have changed since the previous snapshot was taken.\n\n\nTo take an incremental backup, complete the following steps:\n\n\n\n\n\n\nCheck that changed block tracking is enabled:\n\n\npython\nis_cbt_enabled = session.xenapi.VDI.get_cbt_enabled(\nvdi_ref\n)\n\n\nIf the value of \nis_cbt_enabled\n is not \ntrue\n, you must complete the steps in the \nSetting up changed block tracking\n section, before taking incremental backups.\nFor more information, see \nIncremental backup sets\n.\n\n\nIf changed block tracking is disabled and this is unexpected, this state might indicate that the host or SR has crashed since you last took an incremental backup or that a XenServer user has disabled changed block tracking.\n\n\n\n\n\n\nTake a snapshot of the VDI:\n\n\npython\nsnapshot_vdi_ref = session.xenapi.VDI.snapshot(\nvdi_ref\n)\n\n\n\n\n\n\nCompare this snapshot to a previous snapshot to find the changed blocks:\n\n\npython\nbitmap = session.xenapi.VDI.list_changed_blocks(\nbase_snapshot_vdi_ref\n, \nsnapshot_vdi_ref\n)\n\n\nThis call returns a base64-encoded bitmap that indicates which blocks have changed.\nFor more information, see \nGet the list of blocks that changed between VDIs\n.\n\n\n\n\n\n\nGet details for a list of connections that can be used to use to access the VDI snapshot over the NBD protocol.\n\n\npython\nconnections = session.xenapi.VDI.get_nbd_info(\nsnapshot_vdi_ref\n)\n\n\nThis call returns a list of connection details that are specific to this session.\nEach set of connection details in the list contains a dictionary of the parameters required for an NBD client connection.\nFor more information, see \nGetting NBD connection information for a VDI\n.\n\n\n\n\nNote\n\n\nEnsure that this session with the host remains logged in until after you have finished reading from the network block device.\n\n\n\n\n\n\n\n\nFrom your NBD client, complete the following steps to export the changed blocks to the backup location.\n    For example, when using the Linux \nnbd-client\n:\n\n\n\n\n\n\nConnect to the NBD server.\n\n\npython\nnbd-client \naddress\n \nport\n -N \nexportname\n -cacertfile \ncacert\n\n      -tlshostname \nsubject\n\n\n\n\n\n\nThe \naddress\n, \nport\n, \nexportname\n, and \nsubject\n values passed as parameters to the connection command are the values returned by the \nget_nbd_info\n call.\n\n\n\n\n\n\nThe \ncacert\n is a file containing one or more trusted Certificate Authority certificates of which at least one has signed the NBD server's TLS certificate.\n   That TLS certificate is included in the values returned by the \nget_nbd_info\n call.\n   If the TLS certificate returned by the \nget_nbd_info\n call is self-signed, it can be used as the value of \ncacert\n here to authenticate itself.\n\n\n\n\n\n\nFor more information about using these values, see \nGetting NBD connection information for a VDI\n.\n\n\n\n\n\n\nRead off the blocks that are marked as changed in the bitmap returned from step 3.\n\n\n\n\n\n\nDisconnect from the block device:\n\n\npython\nnbd-client -d \nblock_device\n\n\n\n\n\n\nOptional: We recommend that you retain the bitmap associated with each changed block export at your backup location.\n\n\n\n\n\n\nTo complete the preceding steps, you can use any NBD client implementation that supports the \u201cfixed newstyle\u201d version of the NBD protocol.\nFor more information, see \nExporting the changed blocks using an NBD client\n.\n\n\n\n\n\n\nOptional: On the host, delete the VDI snapshot, but retain the metadata:\n\n\npython\nsession.xenapi.vdi.data_destroy(\nsnapshot_vdi_ref\n)\n\n\nThis frees up space on the host or SR.\n\n\nFor more information, see \nDeleting VDI snapshot data and retaining the snapshot metadata\n.\n\n\n\n\n\n\nRestoring a VDI from exported changed block data\n\n\nWhen you want to use your incremental backups to restore or import data from a VDI, you cannot use individual exports of changed blocks to do this.\nYou must first coalesce the exported changed blocks onto a base snapshot.\nUse this coalesced VDI to restore or import backed up data.\n\n\n\n\n\n\nCreate a coalesced VDI.\n\n\nFor each set of exported changed blocks between the base snapshot and the snapshot you want to restore to, create a coalesced VDI from a previous base VDI and the subsequent set of exported changed blocks.\nEnsure that you apply sets of the changed blocks to the base VDI in the order that they were snapshotted.\n\n\nTo create a coalesced VDI from a base VDI and the subsequent set of exported changed blocks, complete the following steps:\n\n\n\n\n\n\nGet the bitmap that was used in step 3 to derive this set of exported changed blocks.\n\n\n\n\n\n\nFor each block in the VDI:\n\n\n\n\n\n\nIf the bitmap indicates that the block has changed, read the block data from the set of exported changed blocks and append that data to the coalesced VDI.\n\n\n\n\n\n\nIf the bitmap indicates that the block has not changed, read the block data from the base VDI and append that data to the coalesced VDI.\n\n\n\n\n\n\n\n\n\n\nUse the coalesced VDI as the base VDI for the next iteration of this step.\n    Or, if you have reached the target snapshot level, use this coalesced VDI in the next step to restore a VDI in XenServer.\n\n\n\n\n\n\nFor more information, see \nCoalescing changed blocks onto a base VDI\n.\n\n\nYou can now use this coalesced VDI to either import backed up data into a new VDI or to restore an existing VDI.\n\n\n\n\n\n\nOptional: Create a new VM and new VDI.\n\n\nYou can create a new VM and new VDI to import the coalesced VDI into.\nHowever, if you intend to use the coalesced VDI to restore an existing VDI, you can skip this step.\n\n\nTo create a new VM and new VDI, complete the following steps\n\n\n\n\n\n\nCreate a new VDI:\n\n\npython\nvdi_record = {\n     \"SR\": \nsr\n,\n     \"virtual_size\": \nsize\n,\n     \"type\": \"user\",\n     \"sharable\": False,\n     \"read_only\": False,\n     \"other_config\": {},\n     \"name_label\": \"\nname_label\n\"\n }\n vdi_ref = session.xenapi.VDI.create(vdi_record)\n vdi_uuid = session.xenapi.VDI.get_uuid(vdi_ref)\n\n\nWhere \nsr\n is a reference to the SR that the original VDI was located on and \nsize\n is the size of the original VDI.\n\n\n\n\n\n\nTo create a new VM that uses the VDI created in the previous step, import the VM metadata associated with the snapshot level you are using to restore the VDI:\n\n\n```python\nvdi_string = \"\nvdi:%s=%s\" % (\n, \n)\n\n\ntask_ref = session.xenapi.task.create(\"import_vm\", \"Task to track vm import\")\n\n\nurl = ('https://%s/import_metadata?session_id=%s\ntask_id=%s%s'\n       % (host, session._session, task_ref, vdi_string))\n\n\nwith open(\n, 'r') as filehandle:\n    urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)\n    with requests.Session() as http_session:\n        request = http_session.put(url, filehandle, verify=False)\n        request.raise_for_status()\n```\n\n\nWhere \nvm_import_path\n is the location of the VM metadata.\n\n\nThe \nvdi:\n query parameter changes the VM from pointing to its original VDI to pointing to the new VDI created in the previous step.\nYou might want to create multiple new VDIs.\nIf you want to change multiple VDI references for your new VM, add a \nvdi:\n query parameter for each VDI to the import URL.\n\n\nThe new VM is created from the imported metadata and its VDI reference is updated to point at the VDI created in the previous step.\nYou can extract a reference to this new VM from the result of the task.\nFor more information, see the \nsamples on GitHub\n.\n\n\n\n\n\n\n\n\n\n\nImport the coalesced VDI snapshot to the XenServer host at the UUID of the VDI you want to replace with the restored version.\n    This VDI can be either an existing VDI or the VDI created in the previous step.\n\n\nIn Python, you can use the following code:\n\n\npython\nsession_id = session._session\nurl = ('https://%s/import_raw_vdi?session_id=%s\nvdi=%s\nformat=%s'\n       % (\nxs_host\n, session_id, \nvdi_uuid\n, 'raw'))\nwith open(\nimport_path\n, 'r') as filehandle:\n    urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)\n    with requests.Session() as http_session:\n        request = http_session.put(url, filehandle, verify=False)\n        request.raise_for_status()\n\n\nWhere \nvdi_uuid\n is the UUID of the VDI you want to overwrite with the restored data from the coalesced VDI and \nimport_path\n is the location of the coalesced VDI.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/getting-started/#getting-started-using-changed-block-tracking", 
            "text": "This section steps through the process of using changed block tracking to create incremental backups.  Before getting started with changed block tracking, we recommend that you read the Citrix XenServer Software Developer Kit Guide.\nThis document contains information to help you become familiar with developing for XenServer.  The examples provided in these steps use the Python binding for the Management API.    For more information about the individual RPC calls, see the  Citrix XenServer Management API    For more detailed information about individual steps in this process, see the following chapters.    Full Python examples are provided on  GitHub .  The NBD connection examples provided in these steps use the Linux nbd-client.\nHowever, you can use any NBD client that supports the \"fixed newstyle\" version of the NBD protocol.\nFor more information, see  the NBD protocol documentation .   Note  If you are using the Linux upstream NBD client, a minimum version of 3.15 is required to support TLS.", 
            "title": "Getting started using changed block tracking"
        }, 
        {
            "location": "/getting-started/#prerequisites", 
            "text": "Before you start, set up or implement an NBD client at the backup location that supports the \"fixed newstyle\" version of the NBD protocol.\nFor more information, see  Exporting the changed blocks using an NBD client .  Enable NBD connections on your network.\nFor more information, see  Enabling NBD connections on XenServer .", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/getting-started/#procedure", 
            "text": "This procedure is broken down into three sections:    Setting up changed block tracking \n    Perform the steps in this section once, when you start using changed\n    block tracking, to enable the changed block tracking capability and\n    export a base snapshot that the incremental, changed block exported\n    data is compared to.    Taking incremental backups \n    Perform the steps in this section every time you want to take an\n    incremental back up of the changed blocks in a VDI.    Restoring a VDI from exported changed block data \n    Perform the steps in this section if you want to use your backed up\n    data to restore a VDI to an earlier state.", 
            "title": "Procedure"
        }, 
        {
            "location": "/getting-started/#setting-up-changed-block-tracking", 
            "text": "Before you can take incremental backups of a VDI using changed block tracking, you must first enable changed block tracking on the VDI and export a base snapshot.\nTo set up changed block tracking for a VDI, complete the following steps    Use the Management API to establish a XenAPI session on the\n    XenServer host:  ```python\nimport XenAPI\nimport shutil\nimport urllib3\nimport requests  session = XenAPI.xapi_local()\nsession.xenapi.login_with_password(\" \", \" \", \" \", \" \")\n```    Optional : If you intend to create a new VM and new VDIs to restore your backed up data to, you must also export your VM metadata.\n    Ensure that you export a copy of the VM metadata any time your VM properties change.\n    This can be done by using HTTPS or by using the command line.  ```python\nsession_id = session._session\nurl = (\"https://%s/export_metadata?session_id=%s uuid=%s\"\n        \" export_snapshots=false\"\n        % ( , session_id,  ))  with requests.Session() as session:\n    urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)\n    request = session.get(url, verify=False, stream=True)\n    with open( , 'wb') as filehandle:\n        shutil.copyfileobj(request.raw, filehandle)\n    request.raise_for_status()\n```  Where  export_path  is the location to save the VM metadata to.  The export URL includes the parameter  export_snapshots=false .\nThis parameter ensures that the snapshot history is not included in the VM metadata backup.\nThe VM metadata is used to create a new VM and this snapshot history does not apply to the new VM.  If you intend to use your backed up data only to restore existing VDIs and VMs, you can skip this step.    Get a reference for the VDI you want to snapshot:  python\nvdi_ref = session.xenapi.VDI.get_by_uuid(\" vdi_uuid \")    Enable changed block tracking for the VDI:  python\nsession.xenapi.VDI.enable_cbt( vdi_ref )  For more information, see  Using changed block tracking with a virtual disk image .    Take a snapshot of the VDI:  python\nbase_snapshot_vdi_ref = session.xenapi.VDI.snapshot( vdi_ref )  This VDI snapshot is the base snapshot.    Export the base VDI snapshot to the backup location. This can be done by using HTTPS or by using the command line.  For example, at the xe command line run:  python\nxe vdi-export uuid= base-snapshot-vdi-uuid  filename= name of export  Or, in Python, you can use the following code:  python\nsession_id = session._session\nurl = ('https://%s/export_raw_vdi?session_id=%s vdi=%s format=raw'\n       % ( xs_host , session_id,  base_snapshot_vdi_uuid ))\nwith requests.Session() as http_session:\n    urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)\n    request = http_session.get(url, verify=False, stream=True)\n    with open( export_path , 'wb') as filehandle:\n        shutil.copyfileobj(request.raw, filehandle)\n    request.raise_for_status()  Where  export_path  is the location you want to write the exported VDI to.    Optional: For each VDI snapshot, delete the snapshot data, but retain the metadata:  python\nsession.xenapi.VDI.data_destroy( base_snapshot_vdi_ref )  This frees up space on the host or SR.  For more information, see  Deleting VDI snapshot data and retaining the snapshot metadata .", 
            "title": "Setting up changed block tracking"
        }, 
        {
            "location": "/getting-started/#taking-incremental-backups", 
            "text": "After taking the initial VDI snapshot and exporting all the data, the following steps can be repeated every time an incremental backup is taken of the VDI.\nThese incremental backups export only the blocks that have changed since the previous snapshot was taken.  To take an incremental backup, complete the following steps:    Check that changed block tracking is enabled:  python\nis_cbt_enabled = session.xenapi.VDI.get_cbt_enabled( vdi_ref )  If the value of  is_cbt_enabled  is not  true , you must complete the steps in the  Setting up changed block tracking  section, before taking incremental backups.\nFor more information, see  Incremental backup sets .  If changed block tracking is disabled and this is unexpected, this state might indicate that the host or SR has crashed since you last took an incremental backup or that a XenServer user has disabled changed block tracking.    Take a snapshot of the VDI:  python\nsnapshot_vdi_ref = session.xenapi.VDI.snapshot( vdi_ref )    Compare this snapshot to a previous snapshot to find the changed blocks:  python\nbitmap = session.xenapi.VDI.list_changed_blocks( base_snapshot_vdi_ref ,  snapshot_vdi_ref )  This call returns a base64-encoded bitmap that indicates which blocks have changed.\nFor more information, see  Get the list of blocks that changed between VDIs .    Get details for a list of connections that can be used to use to access the VDI snapshot over the NBD protocol.  python\nconnections = session.xenapi.VDI.get_nbd_info( snapshot_vdi_ref )  This call returns a list of connection details that are specific to this session.\nEach set of connection details in the list contains a dictionary of the parameters required for an NBD client connection.\nFor more information, see  Getting NBD connection information for a VDI .   Note  Ensure that this session with the host remains logged in until after you have finished reading from the network block device.     From your NBD client, complete the following steps to export the changed blocks to the backup location.\n    For example, when using the Linux  nbd-client :    Connect to the NBD server.  python\nnbd-client  address   port  -N  exportname  -cacertfile  cacert \n      -tlshostname  subject    The  address ,  port ,  exportname , and  subject  values passed as parameters to the connection command are the values returned by the  get_nbd_info  call.    The  cacert  is a file containing one or more trusted Certificate Authority certificates of which at least one has signed the NBD server's TLS certificate.\n   That TLS certificate is included in the values returned by the  get_nbd_info  call.\n   If the TLS certificate returned by the  get_nbd_info  call is self-signed, it can be used as the value of  cacert  here to authenticate itself.    For more information about using these values, see  Getting NBD connection information for a VDI .    Read off the blocks that are marked as changed in the bitmap returned from step 3.    Disconnect from the block device:  python\nnbd-client -d  block_device    Optional: We recommend that you retain the bitmap associated with each changed block export at your backup location.    To complete the preceding steps, you can use any NBD client implementation that supports the \u201cfixed newstyle\u201d version of the NBD protocol.\nFor more information, see  Exporting the changed blocks using an NBD client .    Optional: On the host, delete the VDI snapshot, but retain the metadata:  python\nsession.xenapi.vdi.data_destroy( snapshot_vdi_ref )  This frees up space on the host or SR.  For more information, see  Deleting VDI snapshot data and retaining the snapshot metadata .", 
            "title": "Taking incremental backups"
        }, 
        {
            "location": "/getting-started/#restoring-a-vdi-from-exported-changed-block-data", 
            "text": "When you want to use your incremental backups to restore or import data from a VDI, you cannot use individual exports of changed blocks to do this.\nYou must first coalesce the exported changed blocks onto a base snapshot.\nUse this coalesced VDI to restore or import backed up data.    Create a coalesced VDI.  For each set of exported changed blocks between the base snapshot and the snapshot you want to restore to, create a coalesced VDI from a previous base VDI and the subsequent set of exported changed blocks.\nEnsure that you apply sets of the changed blocks to the base VDI in the order that they were snapshotted.  To create a coalesced VDI from a base VDI and the subsequent set of exported changed blocks, complete the following steps:    Get the bitmap that was used in step 3 to derive this set of exported changed blocks.    For each block in the VDI:    If the bitmap indicates that the block has changed, read the block data from the set of exported changed blocks and append that data to the coalesced VDI.    If the bitmap indicates that the block has not changed, read the block data from the base VDI and append that data to the coalesced VDI.      Use the coalesced VDI as the base VDI for the next iteration of this step.\n    Or, if you have reached the target snapshot level, use this coalesced VDI in the next step to restore a VDI in XenServer.    For more information, see  Coalescing changed blocks onto a base VDI .  You can now use this coalesced VDI to either import backed up data into a new VDI or to restore an existing VDI.    Optional: Create a new VM and new VDI.  You can create a new VM and new VDI to import the coalesced VDI into.\nHowever, if you intend to use the coalesced VDI to restore an existing VDI, you can skip this step.  To create a new VM and new VDI, complete the following steps    Create a new VDI:  python\nvdi_record = {\n     \"SR\":  sr ,\n     \"virtual_size\":  size ,\n     \"type\": \"user\",\n     \"sharable\": False,\n     \"read_only\": False,\n     \"other_config\": {},\n     \"name_label\": \" name_label \"\n }\n vdi_ref = session.xenapi.VDI.create(vdi_record)\n vdi_uuid = session.xenapi.VDI.get_uuid(vdi_ref)  Where  sr  is a reference to the SR that the original VDI was located on and  size  is the size of the original VDI.    To create a new VM that uses the VDI created in the previous step, import the VM metadata associated with the snapshot level you are using to restore the VDI:  ```python\nvdi_string = \" vdi:%s=%s\" % ( ,  )  task_ref = session.xenapi.task.create(\"import_vm\", \"Task to track vm import\")  url = ('https://%s/import_metadata?session_id=%s task_id=%s%s'\n       % (host, session._session, task_ref, vdi_string))  with open( , 'r') as filehandle:\n    urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)\n    with requests.Session() as http_session:\n        request = http_session.put(url, filehandle, verify=False)\n        request.raise_for_status()\n```  Where  vm_import_path  is the location of the VM metadata.  The  vdi:  query parameter changes the VM from pointing to its original VDI to pointing to the new VDI created in the previous step.\nYou might want to create multiple new VDIs.\nIf you want to change multiple VDI references for your new VM, add a  vdi:  query parameter for each VDI to the import URL.  The new VM is created from the imported metadata and its VDI reference is updated to point at the VDI created in the previous step.\nYou can extract a reference to this new VM from the result of the task.\nFor more information, see the  samples on GitHub .      Import the coalesced VDI snapshot to the XenServer host at the UUID of the VDI you want to replace with the restored version.\n    This VDI can be either an existing VDI or the VDI created in the previous step.  In Python, you can use the following code:  python\nsession_id = session._session\nurl = ('https://%s/import_raw_vdi?session_id=%s vdi=%s format=%s'\n       % ( xs_host , session_id,  vdi_uuid , 'raw'))\nwith open( import_path , 'r') as filehandle:\n    urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)\n    with requests.Session() as http_session:\n        request = http_session.put(url, filehandle, verify=False)\n        request.raise_for_status()  Where  vdi_uuid  is the UUID of the VDI you want to overwrite with the restored data from the coalesced VDI and  import_path  is the location of the coalesced VDI.", 
            "title": "Restoring a VDI from exported changed block data"
        }, 
        {
            "location": "/enabling-nbd/", 
            "text": "Enabling NBD connections on XenServer\n\n\nXenServer acts as an NBD server and makes VDI snapshots available over NBD connections.\nHowever, to connect to XenServer over an NBD connection, you must enable NBD connections for one or more networks.\n\n\n\n\nImportant\n\n\nWe recommend that you use a dedicated network for your NBD traffic.\n\n\n\n\nBy default, NBD connections are not enabled on any networks.\n\n\n\n\nNote\n\nNetworks associated with a XenServer pool that have NBD connections enabled must either all have the \nnbd\n purpose or all have the \ninsecure_nbd\n purpose. You cannot have a mix of normal NBD networks (\nFORCEDTLS\n) and insecure NBD networks (\nNOTLS\n).\nTo switch the purpose of all networks, you must first disable normal NBD connections on all networks before enabling either normal or insecure NBD connections on any networks.\n\n\n\n\nEnabling an NBD connection for a network (\nFORCEDTLS\n mode)\n\n\nWe recommend that you use TLS in your NBD connections.\nWhen NBD connections with TLS are enabled, any NBD clients that attempt to connect to XenServer must use TLSv1.2.\nThe NBD server runs in \nFORCEDTLS\n mode with the \"fixed newstyle\" NBD handshake.\nFor more information, see the \nNBD protocol documentation\n.\n\n\nTo enable NBD connections with TLS, use the \npurpose\n parameter of the network.\nSet this parameter to include the value \nnbd\n.\nEnsure that you wait for the setting to propagate before attempting to use this network for NBD connections.\nThe time it takes for the setting to propagate depends on your network and is at least 10 seconds.\nWe recommend that you use a retry loop when making the NBD connection.\n\n\nExamples\n\n\nYou can use any of our supported language bindings to enable NBD connections.\nThe following examples show how to do it in Python and at the xe command line.\n\n\nPython:\n\n\nsession\n.\nxenapi\n.\nnetwork\n.\nadd_purpose\n(\nnetwork_ref\n,\n \nnbd\n)\n\n\n\n\n\n\nxe command line:\n\n\nxe\n \nnetwork\n-\nparam\n-\nadd\n \nparam\n-\nname\n=\npurpose\n \nparam\n-\nkey\n=\nnbd\n \nuuid\n=\nnetwork\n-\nuuid\n\n\n\n\n\n\nEnabling an insecure NBD connection for a network (\nNOTLS\n mode)\n\n\nWe recommend that you do not enable insecure NBD connections.\nInstead use \nFORCEDTLS\n NBD connections.\nHowever, the ability to connect to the XenServer over an insecure NBD connection is provided for development and testing with the NBD server operating in \nNOTLS\n mode as described in the NBD protocol.\n\n\nTo enable insecure NBD connections, use the \npurpose\n parameter of the network.\nSet this parameter to include the value \ninsecure_nbd\n.\nEnsure that you wait for the setting to propagate before attempting to use this network for NBD connections.\nThe time it takes for the setting to propagate depends on your network and is at least 10 seconds.\nWe recommend that you use a retry loop when making the NBD connection.\n\n\nExamples\n\n\nYou can use any of our supported language bindings to enable insecure NBD connections.\nThe following examples show how to do it in Python and at the xe command line.\n\n\nPython:\n\n\nsession\n.\nxenapi\n.\nnetwork\n.\nadd_purpose\n(\nnetwork_ref\n,\n \ninsecure_nbd\n)\n\n\n\n\n\n\nxe command line:\n\n\nxe\n \nnetwork\n-\nparam\n-\nadd\n \nparam\n-\nname\n=\npurpose\n \nparam\n-\nkey\n=\ninsecure_nbd\n \nuuid\n=\nnetwork\n-\nuuid\n\n\n\n\n\n\nDisabling NBD connections for a network\n\n\nTo disable NBD connections for a network, remove the NBD values from the \npurpose\n parameter of the network.\n\n\nExamples\n\n\nYou can use any of our supported language bindings to disable NBD connections.\nThe following examples show how to do it in Python and at the xe command line.\n\n\nPython:\n\n\nsession\n.\nxenapi\n.\nnetwork\n.\nremove_purpose\n(\nnetwork_ref\n,\n \nnbd\n)\n\n\n\n\n\n\nOr, for insecure NBD connections:\n\n\nsession\n.\nxenapi\n.\nnetwork\n.\nremove_purpose\n(\nnetwork_ref\n,\n \ninsecure_nbd\n)\n\n\n\n\n\n\nxe command line:\n\n\nxe\n \nnetwork\n-\nparam\n-\nremove\n \nparam\n-\nname\n=\npurpose\n \nparam\n-\nkey\n=\nnbd\n \nuuid\n=\nnetwork\n-\nuuid\n\n\n\n\n\n\nOr, for insecure NBD connections:\n\n\nxe\n \nnetwork\n-\nparam\n-\nremove\n \nparam\n-\nname\n=\npurpose\n \nparam\n-\nkey\n=\ninsecure_nbd\n \nuuid\n=\nnetwork\n-\nuuid", 
            "title": "Enabling NBD connection"
        }, 
        {
            "location": "/enabling-nbd/#enabling-nbd-connections-on-xenserver", 
            "text": "XenServer acts as an NBD server and makes VDI snapshots available over NBD connections.\nHowever, to connect to XenServer over an NBD connection, you must enable NBD connections for one or more networks.   Important  We recommend that you use a dedicated network for your NBD traffic.   By default, NBD connections are not enabled on any networks.   Note \nNetworks associated with a XenServer pool that have NBD connections enabled must either all have the  nbd  purpose or all have the  insecure_nbd  purpose. You cannot have a mix of normal NBD networks ( FORCEDTLS ) and insecure NBD networks ( NOTLS ).\nTo switch the purpose of all networks, you must first disable normal NBD connections on all networks before enabling either normal or insecure NBD connections on any networks.", 
            "title": "Enabling NBD connections on XenServer"
        }, 
        {
            "location": "/enabling-nbd/#enabling-an-nbd-connection-for-a-network-forcedtls-mode", 
            "text": "We recommend that you use TLS in your NBD connections.\nWhen NBD connections with TLS are enabled, any NBD clients that attempt to connect to XenServer must use TLSv1.2.\nThe NBD server runs in  FORCEDTLS  mode with the \"fixed newstyle\" NBD handshake.\nFor more information, see the  NBD protocol documentation .  To enable NBD connections with TLS, use the  purpose  parameter of the network.\nSet this parameter to include the value  nbd .\nEnsure that you wait for the setting to propagate before attempting to use this network for NBD connections.\nThe time it takes for the setting to propagate depends on your network and is at least 10 seconds.\nWe recommend that you use a retry loop when making the NBD connection.", 
            "title": "Enabling an NBD connection for a network (FORCEDTLS mode)"
        }, 
        {
            "location": "/enabling-nbd/#examples", 
            "text": "You can use any of our supported language bindings to enable NBD connections.\nThe following examples show how to do it in Python and at the xe command line.  Python:  session . xenapi . network . add_purpose ( network_ref ,   nbd )   xe command line:  xe   network - param - add   param - name = purpose   param - key = nbd   uuid = network - uuid", 
            "title": "Examples"
        }, 
        {
            "location": "/enabling-nbd/#enabling-an-insecure-nbd-connection-for-a-network-notls-mode", 
            "text": "We recommend that you do not enable insecure NBD connections.\nInstead use  FORCEDTLS  NBD connections.\nHowever, the ability to connect to the XenServer over an insecure NBD connection is provided for development and testing with the NBD server operating in  NOTLS  mode as described in the NBD protocol.  To enable insecure NBD connections, use the  purpose  parameter of the network.\nSet this parameter to include the value  insecure_nbd .\nEnsure that you wait for the setting to propagate before attempting to use this network for NBD connections.\nThe time it takes for the setting to propagate depends on your network and is at least 10 seconds.\nWe recommend that you use a retry loop when making the NBD connection.", 
            "title": "Enabling an insecure NBD connection for a network (NOTLS mode)"
        }, 
        {
            "location": "/enabling-nbd/#examples_1", 
            "text": "You can use any of our supported language bindings to enable insecure NBD connections.\nThe following examples show how to do it in Python and at the xe command line.  Python:  session . xenapi . network . add_purpose ( network_ref ,   insecure_nbd )   xe command line:  xe   network - param - add   param - name = purpose   param - key = insecure_nbd   uuid = network - uuid", 
            "title": "Examples"
        }, 
        {
            "location": "/enabling-nbd/#disabling-nbd-connections-for-a-network", 
            "text": "To disable NBD connections for a network, remove the NBD values from the  purpose  parameter of the network.", 
            "title": "Disabling NBD connections for a network"
        }, 
        {
            "location": "/enabling-nbd/#examples_2", 
            "text": "You can use any of our supported language bindings to disable NBD connections.\nThe following examples show how to do it in Python and at the xe command line.  Python:  session . xenapi . network . remove_purpose ( network_ref ,   nbd )   Or, for insecure NBD connections:  session . xenapi . network . remove_purpose ( network_ref ,   insecure_nbd )   xe command line:  xe   network - param - remove   param - name = purpose   param - key = nbd   uuid = network - uuid   Or, for insecure NBD connections:  xe   network - param - remove   param - name = purpose   param - key = insecure_nbd   uuid = network - uuid", 
            "title": "Examples"
        }, 
        {
            "location": "/using-with-vdi/", 
            "text": "Using changed block tracking with a virtual disk image\n\n\nThe changed block tracking capability can be enabled and disabled for individual virtual disk images (VDIs).\n\n\nIncremental backup sets\n\n\nWhen you enable changed block tracking for a VDI you start a new set of incremental backups for that VDI.\nThe first action you must take when starting a set of incremental backups is to create a baseline snapshot and to backup its full data.\n\n\nAfter you disable changed block tracking, or after changed block tracking is disabled by XenServer or a user, no further incremental backups can be added to this set.\nIf changed block tracking is enabled again, you must take another baseline snapshot and start a new set of incremental backups.\n\n\nYou cannot compare VDI snapshots taken as part of one set of incremental backups with VDI snapshots taken as part of a different set of incremental backups.\nIf you attempt to list the changed blocks between snapshots that are part of different sets, you get an error with the message \nSource and target VDI are unrelated\n.\n\n\nYou can use some or all of the data in previous incremental backup sets to create VDIs that you can use to restore the state of a VDI.\nFor more information, see \nCoalescing changed blocks onto a base VDI\n.\n\n\nEnabling changed block tracking for a VDI\n\n\nBy default, changed block tracking is not enabled for a VDI.\nYou can enable changed block tracking by using the \nenable_cbt\n call.\n\n\nWhen changed block tracking is enabled for a VDI, additional log files are created on the SR to list the changes since the last backup.\nBlocks of 64 kB within the VDI are tracked and changes to these blocks recorded in the log layer.\n\n\nThe associated VM remains in the same state as before changed block tracking was enabled.\n\n\nTo enable changed block tracking, an SR must be attached, be writable, and have enough free space for the log files to be created on it.\nThe associated VM can be in any state when changed block tracking is enabled or disabled.\nIt is not required that the VM be offline.\n\n\nChanged block tracking can only be enabled for a VDI that is one of the following types:\n\n\n\n\n\n\nuser\n\n\n\n\n\n\nsystem\n\n\n\n\n\n\nIn addition, if the \nVDI.on_boot\n field is set to \nreset\n, you cannot enable changed block tracking for the VDI.\n\n\nExamples\n\n\nYou can use any of our supported language bindings to enable changed block tracking for a VDI.\nThe following examples show how to do it in Python and at the xe command line.\n\n\nPython:\n\n\nsession\n.\nxenapi\n.\nVDI\n.\nenable_cbt\n(\nvdi_ref\n)\n\n\n\n\n\n\nxe command line:\n\n\nxe\n \nvdi\n-\nenable\n-\ncbt\n \nuuid\n=\nvdi\n-\nuuid\n\n\n\n\n\n\nErrors\n\n\nYou might see the following errors when using this call:\n\n\nVDI_MISSING\n:\n\n\n\n\n\n\nThe call cannot find the VDI.\n\n\nCheck that the reference or UUID you are using to refer to the VDI is correct. Check that the VDI exists.\n\n\n\n\n\n\nVDI_INCOMPATIBLE_TYPE\n:\n\n\n\n\n\n\nThe VDI is of a type that does not support changed block tracking.\n\n\nCheck that the type of the VDI is \nsystem\n or \nuser\n.\nYou can use the \nget_type\n call to find out the type of a VDI.\nIf your VDI is an incompatible type, you cannot enable changed block tracking.\nFor more information, see \nChecking the type of a VDI or VDI snapshot\n.\n\n\n\n\n\n\nVDI_ON_BOOT_MODE_INCOMPATIBLE_WITH_OPERATION\n:\n\n\n\n\n\n\nThe value of the \non_boot\n field of the VDI is set to \nreset\n.\n\n\nCheck the value of the \non_boot\n field by using the \nget_on_boot\n call.\nIf appropriate, you can use the \nset_on_boot\n call to change the value of this field to \npersist\n.\n\n\n\n\n\n\nSR_NOT_ATTACHED, SR_HAS_NO_PBDS\n:\n\n\n\n\n\n\nThe call cannot find an attached SR.\n\n\nCheck that there is an SR attached to the host and that the SR is writable.\nYou cannot enable changed block tracking unless the host has access to an SR to which the changed block information can be written.\n\n\n\n\n\n\nIf you attempt to enable changed block tracking for a VDI that already has changed block tracking enabled, no error is thrown.\n\n\nDisabling changed block tracking for a VDI\n\n\nYou can disable changed block tracking for a VDI by using the \ndisable_cbt\n call.\n\n\nWhen changed block tracking is disabled for a VDI, the active disks are detached and reattached without the log layer.\nThe associated VM remains in the same state as before changed block tracking was disabled.\n\n\nExamples\n\n\nYou can use any of our supported language bindings to disable changed block tracking for a VDI.\nThe following examples show how to do it in Python and at the xe command line.\n\n\nPython:\n\n\nsession\n.\nxenapi\n.\nVDI\n.\ndisable_cbt\n(\nvdi_ref\n)\n\n\n\n\n\n\nxe command line:\n\n\nxe\n \nvdi\n-\ndisable\n-\ncbt\n \nuuid\n=\nvdi\n-\nuuid\n\n\n\n\n\n\nErrors\n\n\nYou might see the same sorts of errors for this call and you might for the \nenable_cbt\n call.\n\n\nIf you attempt to disable changed block tracking for a VDI that already has changed block tracking disabled, no error is thrown.\n\n\nChecking whether changed block tracking is enabled\n\n\nThe value of the boolean \ncbt_enabled\n VDI field shows whether changed block tracking is enabled for that VDI.\nYou can query the value of this field by using the \nget_cbt_enabled\n call.\n\n\nA return value of \ntrue\n indicated that changed block tracking is enabled for this VDI.\n\n\nExamples\n\n\nYou can use any of our supported languages to check whether a VDI has changed block tracking enabled.\nThe following examples show how to do it in Python and at the xe command line.\n\n\nPython:\n\n\nis_cbt_enabled\n \n=\n \nsession\n.\nxenapi\n.\nVDI\n.\nget_cbt_enabled\n(\nvdi_ref\n)\n\n\n\n\n\n\nxe command line:\n\n\nxe\n \nvdi\n-\nparam\n-\nget\n \nparam\n-\nname\n=\ncbt\n-\nenabled\n \nuuid\n=\nvdi\n-\nuuid", 
            "title": "Using CBT with a VDI"
        }, 
        {
            "location": "/using-with-vdi/#using-changed-block-tracking-with-a-virtual-disk-image", 
            "text": "The changed block tracking capability can be enabled and disabled for individual virtual disk images (VDIs).", 
            "title": "Using changed block tracking with a virtual disk image"
        }, 
        {
            "location": "/using-with-vdi/#incremental-backup-sets", 
            "text": "When you enable changed block tracking for a VDI you start a new set of incremental backups for that VDI.\nThe first action you must take when starting a set of incremental backups is to create a baseline snapshot and to backup its full data.  After you disable changed block tracking, or after changed block tracking is disabled by XenServer or a user, no further incremental backups can be added to this set.\nIf changed block tracking is enabled again, you must take another baseline snapshot and start a new set of incremental backups.  You cannot compare VDI snapshots taken as part of one set of incremental backups with VDI snapshots taken as part of a different set of incremental backups.\nIf you attempt to list the changed blocks between snapshots that are part of different sets, you get an error with the message  Source and target VDI are unrelated .  You can use some or all of the data in previous incremental backup sets to create VDIs that you can use to restore the state of a VDI.\nFor more information, see  Coalescing changed blocks onto a base VDI .", 
            "title": "Incremental backup sets"
        }, 
        {
            "location": "/using-with-vdi/#enabling-changed-block-tracking-for-a-vdi", 
            "text": "By default, changed block tracking is not enabled for a VDI.\nYou can enable changed block tracking by using the  enable_cbt  call.  When changed block tracking is enabled for a VDI, additional log files are created on the SR to list the changes since the last backup.\nBlocks of 64 kB within the VDI are tracked and changes to these blocks recorded in the log layer.  The associated VM remains in the same state as before changed block tracking was enabled.  To enable changed block tracking, an SR must be attached, be writable, and have enough free space for the log files to be created on it.\nThe associated VM can be in any state when changed block tracking is enabled or disabled.\nIt is not required that the VM be offline.  Changed block tracking can only be enabled for a VDI that is one of the following types:    user    system    In addition, if the  VDI.on_boot  field is set to  reset , you cannot enable changed block tracking for the VDI.", 
            "title": "Enabling changed block tracking for a VDI"
        }, 
        {
            "location": "/using-with-vdi/#examples", 
            "text": "You can use any of our supported language bindings to enable changed block tracking for a VDI.\nThe following examples show how to do it in Python and at the xe command line.  Python:  session . xenapi . VDI . enable_cbt ( vdi_ref )   xe command line:  xe   vdi - enable - cbt   uuid = vdi - uuid", 
            "title": "Examples"
        }, 
        {
            "location": "/using-with-vdi/#errors", 
            "text": "You might see the following errors when using this call:  VDI_MISSING :    The call cannot find the VDI.  Check that the reference or UUID you are using to refer to the VDI is correct. Check that the VDI exists.    VDI_INCOMPATIBLE_TYPE :    The VDI is of a type that does not support changed block tracking.  Check that the type of the VDI is  system  or  user .\nYou can use the  get_type  call to find out the type of a VDI.\nIf your VDI is an incompatible type, you cannot enable changed block tracking.\nFor more information, see  Checking the type of a VDI or VDI snapshot .    VDI_ON_BOOT_MODE_INCOMPATIBLE_WITH_OPERATION :    The value of the  on_boot  field of the VDI is set to  reset .  Check the value of the  on_boot  field by using the  get_on_boot  call.\nIf appropriate, you can use the  set_on_boot  call to change the value of this field to  persist .    SR_NOT_ATTACHED, SR_HAS_NO_PBDS :    The call cannot find an attached SR.  Check that there is an SR attached to the host and that the SR is writable.\nYou cannot enable changed block tracking unless the host has access to an SR to which the changed block information can be written.    If you attempt to enable changed block tracking for a VDI that already has changed block tracking enabled, no error is thrown.", 
            "title": "Errors"
        }, 
        {
            "location": "/using-with-vdi/#disabling-changed-block-tracking-for-a-vdi", 
            "text": "You can disable changed block tracking for a VDI by using the  disable_cbt  call.  When changed block tracking is disabled for a VDI, the active disks are detached and reattached without the log layer.\nThe associated VM remains in the same state as before changed block tracking was disabled.", 
            "title": "Disabling changed block tracking for a VDI"
        }, 
        {
            "location": "/using-with-vdi/#examples_1", 
            "text": "You can use any of our supported language bindings to disable changed block tracking for a VDI.\nThe following examples show how to do it in Python and at the xe command line.  Python:  session . xenapi . VDI . disable_cbt ( vdi_ref )   xe command line:  xe   vdi - disable - cbt   uuid = vdi - uuid", 
            "title": "Examples"
        }, 
        {
            "location": "/using-with-vdi/#errors_1", 
            "text": "You might see the same sorts of errors for this call and you might for the  enable_cbt  call.  If you attempt to disable changed block tracking for a VDI that already has changed block tracking disabled, no error is thrown.", 
            "title": "Errors"
        }, 
        {
            "location": "/using-with-vdi/#checking-whether-changed-block-tracking-is-enabled", 
            "text": "The value of the boolean  cbt_enabled  VDI field shows whether changed block tracking is enabled for that VDI.\nYou can query the value of this field by using the  get_cbt_enabled  call.  A return value of  true  indicated that changed block tracking is enabled for this VDI.", 
            "title": "Checking whether changed block tracking is enabled"
        }, 
        {
            "location": "/using-with-vdi/#examples_2", 
            "text": "You can use any of our supported languages to check whether a VDI has changed block tracking enabled.\nThe following examples show how to do it in Python and at the xe command line.  Python:  is_cbt_enabled   =   session . xenapi . VDI . get_cbt_enabled ( vdi_ref )   xe command line:  xe   vdi - param - get   param - name = cbt - enabled   uuid = vdi - uuid", 
            "title": "Examples"
        }, 
        {
            "location": "/deleting-snapshot/", 
            "text": "Deleting VDI snapshot data and retaining the snapshot metadata\n\n\nA VDI snapshot is made up of both data and metadata.\nThe data is the full image of the disk at the time the snapshot was taken.\nThe metadata includes the changed block tracking information.\n\n\nAfter the snapshot data on the host has been exported to the backup location, you can use the \ndata_destroy\n call to delete only the snapshot data and retain only the snapshot metadata on the host.\nThis action converts the snapshot that is stored on the host or SR into a smaller metadata-only snapshot.\nThe \ntype\n field of the snapshot changes to be \ncbt_metadata\n.\n\n\nMetadata-only snapshots are linked to the metadata-only snapshots that precede and follow them in time.\n\n\nYou can use the \ndata_destroy\n call only for snapshots for VDIs that have changed block tracking enabled.\n\n\n\n\nNote\n\n\nThe API also provides a \ndestroy\n call, which deletes both the data in the snapshot and the metadata in the snapshot.\n\n\n\n\nDo not use the \ndestroy\n call to delete snapshots that are part of a set of changed block tracking backups unless you are sure that you no longer need the changed block tracking metadata.\n\n\nFor example, use \ndestroy\n to remove a metadata-only snapshot that is older than age allowed by your retention policy.\n\n\nExamples\n\n\nYou can use any of our supported language bindings to delete the data in a snapshot and convert the snapshot to a metadata only snapshot.\nThe following examples show how to do it in Python and at the xe command line.\n\n\nPython:\n\n\nsession\n.\nxenapi\n.\nVDI\n.\ndata_destroy\n(\nsnapshot_vdi_ref\n)\n\n\n\n\n\n\nxe command line:\n\n\nxe\n \nvdi\n-\ndata\n-\ndestroy\n \nuuid\n=\nsnapshot_vdi_uuid\n\n\n\n\n\n\nErrors\n\n\nYou might see the following errors when using this call:\n\n\nVDI_MISSING\n:\n\n\n\n\n\n\nThe call cannot find the VDI snapshot.\n\n\nCheck that the reference or UUID you are using to refer to the VDI snapshot is correct. Check that the VDI exists.\n\n\n\n\n\n\nVDI_NO_CBT_METADATA\n:\n\n\n\n\n\n\nNo changed block tracking metadata exists for this VDI snapshot.\n\n\nCheck that changed block tracking is enabled for the VDI.\nYou cannot use the \ndata_destroy\n call on VDIs that do not have changed block tracking enabled.\nFor more insformation, see \nUsing changed block tracking with a virtual disk image\n.\n\n\n\n\n\n\nVDI_IN_USE\n:\n\n\n\n\n\n\nThe VDI snapshot is currently in use by another operation.\n\n\nCheck that the VDI snapshot is not being accessed by another client or operation.\nCheck that the VDI is not attached to a VM.\n\n\nIf the VDI snapshot is connected to a VM snapshot by a VBD, you receive this error.\nBefore you can run \nVDI.data_destroy\n on this VDI snapshot, you must remove the VM snapshot.\nUse \nVM.destroy\n to remove the VM snapshot.\n\n\n\n\n\n\nChecking the type of a VDI or VDI snapshot\n\n\nThe value of the \ntype\n VDI field shows what type of VDI or VDI snapshot an object is.\nThe values this field can have are stored in the \nvdi_type\n enum.\nYou can query the value of this field by using the \nget_type\n call.\n\n\nA metadata-only VDI snapshot has the type \ncbt_metadata\n.\n\n\nExamples\n\n\nYou can use any of our supported language bindings to query the VDI type of a VDI or VDI snapshot.\nThe following examples show how to do it in Python and at the xe command line.\n\n\nPython:\n\n\nvdi_type\n \n=\n \nsession\n.\nxenapi\n.\nVDI\n.\nget_type\n(\nsnapshot_vdi_ref\n)\n\n\n\n\n\n\nxe command line:\n\n\nxe\n \nvdi\n-\nparam\n-\nget\n \nparam\n-\nname\n=\ntype\n \nuuid\n=\nsnapshot_vdi_uuid", 
            "title": "Deleting VDI snapshots"
        }, 
        {
            "location": "/deleting-snapshot/#deleting-vdi-snapshot-data-and-retaining-the-snapshot-metadata", 
            "text": "A VDI snapshot is made up of both data and metadata.\nThe data is the full image of the disk at the time the snapshot was taken.\nThe metadata includes the changed block tracking information.  After the snapshot data on the host has been exported to the backup location, you can use the  data_destroy  call to delete only the snapshot data and retain only the snapshot metadata on the host.\nThis action converts the snapshot that is stored on the host or SR into a smaller metadata-only snapshot.\nThe  type  field of the snapshot changes to be  cbt_metadata .  Metadata-only snapshots are linked to the metadata-only snapshots that precede and follow them in time.  You can use the  data_destroy  call only for snapshots for VDIs that have changed block tracking enabled.   Note  The API also provides a  destroy  call, which deletes both the data in the snapshot and the metadata in the snapshot.   Do not use the  destroy  call to delete snapshots that are part of a set of changed block tracking backups unless you are sure that you no longer need the changed block tracking metadata.  For example, use  destroy  to remove a metadata-only snapshot that is older than age allowed by your retention policy.", 
            "title": "Deleting VDI snapshot data and retaining the snapshot metadata"
        }, 
        {
            "location": "/deleting-snapshot/#examples", 
            "text": "You can use any of our supported language bindings to delete the data in a snapshot and convert the snapshot to a metadata only snapshot.\nThe following examples show how to do it in Python and at the xe command line.  Python:  session . xenapi . VDI . data_destroy ( snapshot_vdi_ref )   xe command line:  xe   vdi - data - destroy   uuid = snapshot_vdi_uuid", 
            "title": "Examples"
        }, 
        {
            "location": "/deleting-snapshot/#errors", 
            "text": "You might see the following errors when using this call:  VDI_MISSING :    The call cannot find the VDI snapshot.  Check that the reference or UUID you are using to refer to the VDI snapshot is correct. Check that the VDI exists.    VDI_NO_CBT_METADATA :    No changed block tracking metadata exists for this VDI snapshot.  Check that changed block tracking is enabled for the VDI.\nYou cannot use the  data_destroy  call on VDIs that do not have changed block tracking enabled.\nFor more insformation, see  Using changed block tracking with a virtual disk image .    VDI_IN_USE :    The VDI snapshot is currently in use by another operation.  Check that the VDI snapshot is not being accessed by another client or operation.\nCheck that the VDI is not attached to a VM.  If the VDI snapshot is connected to a VM snapshot by a VBD, you receive this error.\nBefore you can run  VDI.data_destroy  on this VDI snapshot, you must remove the VM snapshot.\nUse  VM.destroy  to remove the VM snapshot.", 
            "title": "Errors"
        }, 
        {
            "location": "/deleting-snapshot/#checking-the-type-of-a-vdi-or-vdi-snapshot", 
            "text": "The value of the  type  VDI field shows what type of VDI or VDI snapshot an object is.\nThe values this field can have are stored in the  vdi_type  enum.\nYou can query the value of this field by using the  get_type  call.  A metadata-only VDI snapshot has the type  cbt_metadata .", 
            "title": "Checking the type of a VDI or VDI snapshot"
        }, 
        {
            "location": "/deleting-snapshot/#examples_1", 
            "text": "You can use any of our supported language bindings to query the VDI type of a VDI or VDI snapshot.\nThe following examples show how to do it in Python and at the xe command line.  Python:  vdi_type   =   session . xenapi . VDI . get_type ( snapshot_vdi_ref )   xe command line:  xe   vdi - param - get   param - name = type   uuid = snapshot_vdi_uuid", 
            "title": "Examples"
        }, 
        {
            "location": "/list-changed-blocks/", 
            "text": "Getting the list of blocks that changed between VDIs\n\n\nYou can use the \nlist_changed_blocks\n call to get a list of the blocks that have changed between two VDIs.\nBoth VDI snapshots must be taken after changed block tracking is enabled on the VDI.\n\n\nThis call takes as parameters references to two VDI snapshots:\n\n\n\n\n\n\nVDI_from\n: The earlier VDI snapshot.\n\n\n\n\n\n\nVDI_to\n: The later VDI snapshot. This VDI \ncannot\n be attached to a VM at the time this comparison is made.\n\n\n\n\n\n\nThis operation does not require the VM associated with the VDIs to be offline at the time the comparison is made.\n\n\nThe changed blocks are listed in a base64-encoded bitmap.\nEach bit in the bitmap indicates whether a 64 kB block in the VDI has been changed in comparison to an earlier snapshot.\nA bit set to 0 indicates that the block is the same.\nA bit set to 1 indicates that the block has changed.\n\n\nThe bit in the first position in the bitmap represents the first block in the VDI.\nFor example, if the bitmap is 01100000, this indicates that the first block has not changed, the second and third blocks have changed, and all other blocks have not changed.\n\n\nExamples\n\n\nYou can use any of our supported languages to get the bitmap that lists the changed blocks between two VDI snapshots.\nThe following examples show how to do it in Python and at the xe command line.\n\n\nPython:\n\n\nbitmap\n \n=\n \nsession\n.\nxenapi\n.\nVDI\n.\nlist_changed_blocks\n(\nprevious_snapshot_vdi_ref\n,\n \nnew_snapshot_vdi_ref\n)\n\n\n\n\n\n\nYou can convert the base64-encoded bitmap this call returns into a human-readable string of 1s and 0s:\n\n\nfrom\n \nbitstring\n \nimport\n \nBitStream\n\n\nimport\n \nbase64\n\n\ndata\n \n=\n \nBitStream\n(\nbytes\n=\nbase64\n.\nb64decode\n(\nbitmap\n))\n\n\n\n\n\n\nxe command line:\n\n\nxe\n \nvdi\n-\nlist\n-\nchanged\n-\nblocks\n \nvdi\n-\nfrom\n-\nuuid\n=\nprevious_snapshot_vdi_uuid\n \nvdi\n-\nto\n-\nuuid\n=\nnew_snapshot_vdi_uuid\n\n\n\n\n\n\nErrors\n\n\nYou might see the following errors when using this call:\n\n\nVDI_MISSING\n:\n\n\n\n\n\n\nThe call cannot find one or both of the VDI snapshots.\n\n\nCheck that the reference or UUID you are using to refer to the VDI snapshot is correct.\nCheck that the VDI snapshot exists.\n\n\n\n\n\n\nVDI_IN_USE\n:\n\n\n\n\n\n\nThe VDI snapshot is currently in use by another operation.\n\n\nCheck that the VDI snapshot is not being accessed by another client or operation.\nCheck that the more recent VDI snapshot is not attached to a VM.\nThe newer VDI in the comparison cannot be attached to a VM at the time of the comparison.\n\n\n\n\n\n\nSource and target VDI are unrelated\n:\n\n\n\n\n\n\nThe VDI snapshots are not linked by changed block metadata.\n\n\nYou can only list changed blocks between snapshots that are taken as part of the same set of incremental backups.\nFor more information, see \nIncremental backup sets\n.", 
            "title": "Getting the list of changes blocks in a VDI"
        }, 
        {
            "location": "/list-changed-blocks/#getting-the-list-of-blocks-that-changed-between-vdis", 
            "text": "You can use the  list_changed_blocks  call to get a list of the blocks that have changed between two VDIs.\nBoth VDI snapshots must be taken after changed block tracking is enabled on the VDI.  This call takes as parameters references to two VDI snapshots:    VDI_from : The earlier VDI snapshot.    VDI_to : The later VDI snapshot. This VDI  cannot  be attached to a VM at the time this comparison is made.    This operation does not require the VM associated with the VDIs to be offline at the time the comparison is made.  The changed blocks are listed in a base64-encoded bitmap.\nEach bit in the bitmap indicates whether a 64 kB block in the VDI has been changed in comparison to an earlier snapshot.\nA bit set to 0 indicates that the block is the same.\nA bit set to 1 indicates that the block has changed.  The bit in the first position in the bitmap represents the first block in the VDI.\nFor example, if the bitmap is 01100000, this indicates that the first block has not changed, the second and third blocks have changed, and all other blocks have not changed.", 
            "title": "Getting the list of blocks that changed between VDIs"
        }, 
        {
            "location": "/list-changed-blocks/#examples", 
            "text": "You can use any of our supported languages to get the bitmap that lists the changed blocks between two VDI snapshots.\nThe following examples show how to do it in Python and at the xe command line.  Python:  bitmap   =   session . xenapi . VDI . list_changed_blocks ( previous_snapshot_vdi_ref ,   new_snapshot_vdi_ref )   You can convert the base64-encoded bitmap this call returns into a human-readable string of 1s and 0s:  from   bitstring   import   BitStream  import   base64  data   =   BitStream ( bytes = base64 . b64decode ( bitmap ))   xe command line:  xe   vdi - list - changed - blocks   vdi - from - uuid = previous_snapshot_vdi_uuid   vdi - to - uuid = new_snapshot_vdi_uuid", 
            "title": "Examples"
        }, 
        {
            "location": "/list-changed-blocks/#errors", 
            "text": "You might see the following errors when using this call:  VDI_MISSING :    The call cannot find one or both of the VDI snapshots.  Check that the reference or UUID you are using to refer to the VDI snapshot is correct.\nCheck that the VDI snapshot exists.    VDI_IN_USE :    The VDI snapshot is currently in use by another operation.  Check that the VDI snapshot is not being accessed by another client or operation.\nCheck that the more recent VDI snapshot is not attached to a VM.\nThe newer VDI in the comparison cannot be attached to a VM at the time of the comparison.    Source and target VDI are unrelated :    The VDI snapshots are not linked by changed block metadata.  You can only list changed blocks between snapshots that are taken as part of the same set of incremental backups.\nFor more information, see  Incremental backup sets .", 
            "title": "Errors"
        }, 
        {
            "location": "/exporting-changed-blocks/", 
            "text": "Export changed blocks over a network block device connection\n\n\nXenServer runs an NBD server on the host that can make VDI snapshots accessible as a network block device to NBD clients.\nThe NBD server listens on port 10809 and uses the \"fixed newstyle\" NBD protocol.\nFor more information, see \nthe NBD protocol documentation\n.\n\n\nNBD connections must be enabled for one or more of the XenServer networks before you can export the changed blocks over NBD.\nFor more information, see \nEnabling NBD connections on XenServer\n.\n\n\nGetting NBD connection information for a VDI\n\n\nFrom a logged in XenAPI session, you can use the \nget_nbd_info\n call to get a list of connection details for a VDI snapshot made available as a network block device.\n\n\nThese connection details are specific to the session that creates them and the NBD client uses this logged in session when making its connection.\nAny set of connection details in the list can be used by the NBD client when accessing the VDI snapshot.\n\n\nEach set of connection details in the list is provided as a dictionary containing the following information:\n\n\naddress\n:\n\n\n\n\nThe IP address (IPv4 or IPv6) of the NBD server.\n\n\n\n\nport\n:\n\n\n\n\nThe TCP port to connect to the XenServer NBD server on.\n\n\n\n\ncert\n:\n\n\n\n\nThe TLS certificate used by the NBD server encoded as a string in PEM format.\n    When XenServer is configured to enable NBD connections in \nFORCEDTLS\n mode, the server presents this certificate during the TLS handshake and the NBD client must verify the server TLS certificate against this TLS certificate.\n    For more information, see \"Verifying TLS certificates for NBD connections\".\n\n\n\n\nexportname\n:\n\n\n\n\n\n\nA token that the NBD client can use to request the export of a VDI from the NBD server.\n    The NBD client provides the value of this token to the NBD server using the \nNBD_OPT_EXPORT_NAME\n option during the NBD option haggling phase of an NBD connection.\n\n\nThis token contains a reference to a logged in XenAPI session.\nThe XenAPI session must remain logged in for this token to continue to be valid.\nBecause the token contains a reference to a XenAPI session, you must handle the token securely to prevent the session being hijacked.\n\n\nThe format of this token is not guaranteed and might change in future releases of XenServer.\nTreat the export name as an opaque token.\n\n\n\n\n\n\nsubject\n:\n\n\n\n\nA subject of the TLS certificate returned as the value of \ncert\n. This field is provided as a convenience.\n\n\n\n\nExamples\n\n\nYou can use any of our supported languages to get the list of NBD connection details for a VDI snapshot.\nThe following examples show how to do it in Python.\n\n\nPython:\n\n\nconnection_list\n \n=\n \nsession\n.\nxenapi\n.\nVDI\n.\nget_nbd_info\n(\nsnapshot_vdi_ref\n)\n\n\n\n\n\n\nThis call requires a logged in XenAPI session that remains logged in while the VDI snapshot is accessed over NBD.\nThis means that this command is not available at the xe command line.\n\n\nErrors\n\n\nYou might see the following errors when using this call:\n\n\nVDI_INCOMPATIBLE_TYPE\n:\n\n\n\n\n\n\nThe VDI is of a type that does not support being accessed as a network block device.\n\n\nCheck that the type of the VDI is not \ncbt_metadata\n.\nYou can use the \nget_type\n call to find out the type of a VDI.\nIf your VDI is \ncbt_metadata\n, you cannot access it as a network block device. For more information, see \nChecking the type of a VDI or VDI snapshot\n.\n\n\n\n\n\n\nAn empty list of connection details\n:\n\n\n\n\n\n\nThe VDI cannot be accessed.\n\n\nCheck that the XenServer host that runs the NBD server has a PIF with an IP address.\n\n\nCheck that you have at least one network in your pool with the purpose \nnbd\n or \ninsecure_nbd\n.\nFor more information, see \nEnabling NBD connections on XenServer\n.\n\n\nCheck that storage repository the VDI is on is attached to a host that is connected to one of the NBD-enabled networks.\n\n\n\n\n\n\nExporting the changed blocks using an NBD client\n\n\nAn NBD client running in the backup location can connect to the NBD server that runs on the XenServer host and access the VDI snapshot by using the provided connection details.\n\n\nThe NBD client that you use to connect to the XenServer NBD server can be any implementation that supports the \u201cfixed newstyle\u201d version of the NBD protocol.\n\n\nWhen choosing or developing an NBD client implementation, consider the following requirements:\n\n\n\n\n\n\nThe NBD client must support the \u201cfixed newstyle\u201d version of the NBD protocol.\n    For more information, see \nthe NBD protocol documentation\n.\n\n\n\n\n\n\nThe NBD client must request an export name returned by the \nget_nbd_info\n call that corresponds to an existing logged in XenAPI session.\n    The client makes this request by using the \nNBD_OPT_EXPORT_NAME\n option during the NBD option haggling phase of the NBD connection.\n\n\n\n\n\n\nThe NBD client must verify the TLS certificate presented by the NBD server by using the information returned by the \nget_nbd_info\n call.\n    For more information, see \u201cVerifying TLS certificates for NBD connections\u201d.\n\n\n\n\n\n\n\n\nNote\n\n\nIf you are using the Linux upstream NBD client, a minimum version of 3.15 is required to support TLS.\n\n\n\n\nAfter the NBD client has made a connection to the XenServer host and accessed the VDI snapshot, you can use the bitmap provided by the \nlist_changed_blocks\n call to select which blocks to read.\nFor more information, see \nGetting the list of blocks that changed between VDIs\n.\n\n\n\n\nNote\n\n\nXenServer supports up to 16 concurrent NBD connections.\n\n\n\n\nVerifying TLS certificates for NBD connections\n\n\nWhen connecting to the NBD server using TLS, the NBD client must verify the certificate that the server presents as part of the TLS handshake.\n\n\nWe recommend that you use one of the following methods of verification depending on your NBD client implementation:\n\n\n\n\n\n\nVerify that the server certificate matches the certificate returned by the \nget_nbd_info\n call.\n\n\n\n\n\n\nVerify that the public key of the server certificate matches the public key of the certificate returned by the \nget_nbd_info\n call.\n\n\n\n\n\n\nAlternative approach\n\n\nAs a less preferred option, it is possible for the NBD client to verify the certificate that the server presents during the TLS handshake by checking that the certificate meets all of the following criteria:\n\n\n\n\n\n\nIt is signed by a trusted Certificate Authority\n\n\n\n\n\n\nIt has an \nAlternative Subject Name\n (or, if absent, a \nSubject\n) that matches the subject returned by the \nget_nbd_info\n call.", 
            "title": "Exporting changed blocks over NBD"
        }, 
        {
            "location": "/exporting-changed-blocks/#export-changed-blocks-over-a-network-block-device-connection", 
            "text": "XenServer runs an NBD server on the host that can make VDI snapshots accessible as a network block device to NBD clients.\nThe NBD server listens on port 10809 and uses the \"fixed newstyle\" NBD protocol.\nFor more information, see  the NBD protocol documentation .  NBD connections must be enabled for one or more of the XenServer networks before you can export the changed blocks over NBD.\nFor more information, see  Enabling NBD connections on XenServer .", 
            "title": "Export changed blocks over a network block device connection"
        }, 
        {
            "location": "/exporting-changed-blocks/#getting-nbd-connection-information-for-a-vdi", 
            "text": "From a logged in XenAPI session, you can use the  get_nbd_info  call to get a list of connection details for a VDI snapshot made available as a network block device.  These connection details are specific to the session that creates them and the NBD client uses this logged in session when making its connection.\nAny set of connection details in the list can be used by the NBD client when accessing the VDI snapshot.  Each set of connection details in the list is provided as a dictionary containing the following information:  address :   The IP address (IPv4 or IPv6) of the NBD server.   port :   The TCP port to connect to the XenServer NBD server on.   cert :   The TLS certificate used by the NBD server encoded as a string in PEM format.\n    When XenServer is configured to enable NBD connections in  FORCEDTLS  mode, the server presents this certificate during the TLS handshake and the NBD client must verify the server TLS certificate against this TLS certificate.\n    For more information, see \"Verifying TLS certificates for NBD connections\".   exportname :    A token that the NBD client can use to request the export of a VDI from the NBD server.\n    The NBD client provides the value of this token to the NBD server using the  NBD_OPT_EXPORT_NAME  option during the NBD option haggling phase of an NBD connection.  This token contains a reference to a logged in XenAPI session.\nThe XenAPI session must remain logged in for this token to continue to be valid.\nBecause the token contains a reference to a XenAPI session, you must handle the token securely to prevent the session being hijacked.  The format of this token is not guaranteed and might change in future releases of XenServer.\nTreat the export name as an opaque token.    subject :   A subject of the TLS certificate returned as the value of  cert . This field is provided as a convenience.", 
            "title": "Getting NBD connection information for a VDI"
        }, 
        {
            "location": "/exporting-changed-blocks/#examples", 
            "text": "You can use any of our supported languages to get the list of NBD connection details for a VDI snapshot.\nThe following examples show how to do it in Python.  Python:  connection_list   =   session . xenapi . VDI . get_nbd_info ( snapshot_vdi_ref )   This call requires a logged in XenAPI session that remains logged in while the VDI snapshot is accessed over NBD.\nThis means that this command is not available at the xe command line.", 
            "title": "Examples"
        }, 
        {
            "location": "/exporting-changed-blocks/#errors", 
            "text": "You might see the following errors when using this call:  VDI_INCOMPATIBLE_TYPE :    The VDI is of a type that does not support being accessed as a network block device.  Check that the type of the VDI is not  cbt_metadata .\nYou can use the  get_type  call to find out the type of a VDI.\nIf your VDI is  cbt_metadata , you cannot access it as a network block device. For more information, see  Checking the type of a VDI or VDI snapshot .    An empty list of connection details :    The VDI cannot be accessed.  Check that the XenServer host that runs the NBD server has a PIF with an IP address.  Check that you have at least one network in your pool with the purpose  nbd  or  insecure_nbd .\nFor more information, see  Enabling NBD connections on XenServer .  Check that storage repository the VDI is on is attached to a host that is connected to one of the NBD-enabled networks.", 
            "title": "Errors"
        }, 
        {
            "location": "/exporting-changed-blocks/#exporting-the-changed-blocks-using-an-nbd-client", 
            "text": "An NBD client running in the backup location can connect to the NBD server that runs on the XenServer host and access the VDI snapshot by using the provided connection details.  The NBD client that you use to connect to the XenServer NBD server can be any implementation that supports the \u201cfixed newstyle\u201d version of the NBD protocol.  When choosing or developing an NBD client implementation, consider the following requirements:    The NBD client must support the \u201cfixed newstyle\u201d version of the NBD protocol.\n    For more information, see  the NBD protocol documentation .    The NBD client must request an export name returned by the  get_nbd_info  call that corresponds to an existing logged in XenAPI session.\n    The client makes this request by using the  NBD_OPT_EXPORT_NAME  option during the NBD option haggling phase of the NBD connection.    The NBD client must verify the TLS certificate presented by the NBD server by using the information returned by the  get_nbd_info  call.\n    For more information, see \u201cVerifying TLS certificates for NBD connections\u201d.     Note  If you are using the Linux upstream NBD client, a minimum version of 3.15 is required to support TLS.   After the NBD client has made a connection to the XenServer host and accessed the VDI snapshot, you can use the bitmap provided by the  list_changed_blocks  call to select which blocks to read.\nFor more information, see  Getting the list of blocks that changed between VDIs .   Note  XenServer supports up to 16 concurrent NBD connections.", 
            "title": "Exporting the changed blocks using an NBD client"
        }, 
        {
            "location": "/exporting-changed-blocks/#verifying-tls-certificates-for-nbd-connections", 
            "text": "When connecting to the NBD server using TLS, the NBD client must verify the certificate that the server presents as part of the TLS handshake.  We recommend that you use one of the following methods of verification depending on your NBD client implementation:    Verify that the server certificate matches the certificate returned by the  get_nbd_info  call.    Verify that the public key of the server certificate matches the public key of the certificate returned by the  get_nbd_info  call.", 
            "title": "Verifying TLS certificates for NBD connections"
        }, 
        {
            "location": "/exporting-changed-blocks/#alternative-approach", 
            "text": "As a less preferred option, it is possible for the NBD client to verify the certificate that the server presents during the TLS handshake by checking that the certificate meets all of the following criteria:    It is signed by a trusted Certificate Authority    It has an  Alternative Subject Name  (or, if absent, a  Subject ) that matches the subject returned by the  get_nbd_info  call.", 
            "title": "Alternative approach"
        }, 
        {
            "location": "/coalescing-blocks/", 
            "text": "Coalescing changed blocks onto a base VDI\n\n\nWhen using backed up data to restore the state of a VDI, you must import a full VDI into XenServer.\nYou cannot import only the sets of changed blocks.\nTo import incremental backups created with changed block tracking data into XenServer, you must first use these incremental backups to create a full VDI.\n\n\nA set of incremental backups created with changed block tracking can be used to create a full VDI whose data is identical to the source VDI at the time an incremental backup was taken.\n\n\nFor more information about incremental backup sets, see \nIncremental backup sets\n.\n\n\nFor example, you have a set of incremental backups that comprises:\n\n\n\n\n\n\nA base snapshot that captures the data for the full VDI.\n\n\n\n\n\n\nBackup 1: The first incremental backup, which consists of a bitmap list of blocks changed since the base snapshot and the data for only those changed blocks.\n\n\n\n\n\n\nBackup 2: The second incremental backup, which consists of a bitmap  list of blocks changed since backup 1 and the data for only those changed blocks.\n\n\n\n\n\n\n\n\nIf you want to restore a VDI on XenServer to the state it was at when backup 2 was taken, you must create a VDI that takes blocks from the base snapshot, changed blocks from backup 1, and changed blocks from backup 2.\nTo do this, you can apply each set of changed blocks in sequence to the base snapshot of the VDI.\n\n\nFirst build up a coalesced VDI by taking unchanged blocks from the base snapshot and changed blocks from those exported at backup 1.\nThe bitmap list of changed blocks that was used to create backup 1 defines which blocks are changed.\n\n\nAfter coalescing the base snapshot with the changed blocks exported at backup 1, you have a full VDI whose data is identical to that of the source VDI at the time backup 1 was taken. Call this coalesced VDI \"VDI 1\".\n\n\n\n\nNext, use this coalesced VDI, VDI 1, to create another coalesced VDI by taking unchanged blocks from VDI 1 and changed blocks from those exported at backup 2.\nThe bitmap list of changed blocks that was used to create backup 2 defines which blocks are changed.\n\n\nAfter coalescing VDI 1 with the changed blocks exported at backup 2, you have a full VDI whose data is identical to that of the source VDI at the time backup 2 was taken.\nCall this coalesced VDI \"VDI 2\".\n\n\n\n\nThis coalesced VDI, VDI 2, can be used to restore the state of the VDI on XenServer at the time that a snapshot was taken for backup 2.\n\n\nWhen creating a coalesced VDI, ensure that you work with your VDIs and changed blocks as binary.\n\n\nEnsure that you verify the integrity of the backed up and restored VDIs.\nFor example, you can do this by computing the checksums of the data.\n\n\nExamples\n\n\nThe following example shows how to create a coalesced VDI.\nThe example shows applying a single set of changed blocks to the base VDI snapshot.\nTo apply multiple sets of changed blocks, you must repeat this process for each set of changed blocks in order from oldest to most recent, using the output from the  previous iteration as the base VDI for the next iteration.\n\n\nPython:\n\n\ndef\n \nwrite_changed_blocks_to_base_VDI\n(\nvdi_path\n,\n \nchanged_block_path\n,\n \nbitmap_path\n,\n \noutput_path\n):\n\n    \nbitmap\n \n=\n \nopen\n(\nbitmap_path\n,\n \nr\n)\n\n    \nvdi\n \n=\n \nopen\n(\nvdi_path\n,\n \nr+b\n)\n\n    \nblocks\n \n=\n \nopen\n(\nchanged_block_path\n,\n \nr+b\n)\n\n    \ncombined_vdi\n \n=\n \nopen\n(\noutput_path\n,\n \nwb\n)\n\n\n    \ntry\n:\n\n        \nbitmap_r\n \n=\n \nbitmap\n.\nread\n()\n\n        \ncb_offset\n \n=\n \n0\n\n        \nfor\n \nx\n \nin\n \nrange\n(\n0\n,\n \nlen\n(\nbitmap_r\n)):\n\n            \noffset\n \n=\n \nx\n \n*\n \nchanged_block_size\n\n            \nif\n \nbitmap_r\n[\nx\n]\n \n==\n \n1\n:\n\n                \nblocks\n.\nseek\n(\ncb_offset\n)\n\n                \nblocks_r\n \n=\n \nblocks\n.\nread\n(\nchanged_block_size\n)\n\n                \ncombined_vdi\n.\nwrite\n(\nblocks_r\n)\n\n                \ncb_offset\n \n+=\n \nchanged_block_size\n\n            \nelse\n:\n\n                \nvdi\n.\nseek\n(\noffset\n)\n\n                \nvdi_r\n \n=\n \nvdi\n.\nread\n(\nchanged_block_size\n)\n\n                \ncombined_vdi\n.\nwrite\n(\nvdi_r\n)", 
            "title": "Coalescing changed blocks onto a base VDI"
        }, 
        {
            "location": "/coalescing-blocks/#coalescing-changed-blocks-onto-a-base-vdi", 
            "text": "When using backed up data to restore the state of a VDI, you must import a full VDI into XenServer.\nYou cannot import only the sets of changed blocks.\nTo import incremental backups created with changed block tracking data into XenServer, you must first use these incremental backups to create a full VDI.  A set of incremental backups created with changed block tracking can be used to create a full VDI whose data is identical to the source VDI at the time an incremental backup was taken.  For more information about incremental backup sets, see  Incremental backup sets .  For example, you have a set of incremental backups that comprises:    A base snapshot that captures the data for the full VDI.    Backup 1: The first incremental backup, which consists of a bitmap list of blocks changed since the base snapshot and the data for only those changed blocks.    Backup 2: The second incremental backup, which consists of a bitmap  list of blocks changed since backup 1 and the data for only those changed blocks.     If you want to restore a VDI on XenServer to the state it was at when backup 2 was taken, you must create a VDI that takes blocks from the base snapshot, changed blocks from backup 1, and changed blocks from backup 2.\nTo do this, you can apply each set of changed blocks in sequence to the base snapshot of the VDI.  First build up a coalesced VDI by taking unchanged blocks from the base snapshot and changed blocks from those exported at backup 1.\nThe bitmap list of changed blocks that was used to create backup 1 defines which blocks are changed.  After coalescing the base snapshot with the changed blocks exported at backup 1, you have a full VDI whose data is identical to that of the source VDI at the time backup 1 was taken. Call this coalesced VDI \"VDI 1\".   Next, use this coalesced VDI, VDI 1, to create another coalesced VDI by taking unchanged blocks from VDI 1 and changed blocks from those exported at backup 2.\nThe bitmap list of changed blocks that was used to create backup 2 defines which blocks are changed.  After coalescing VDI 1 with the changed blocks exported at backup 2, you have a full VDI whose data is identical to that of the source VDI at the time backup 2 was taken.\nCall this coalesced VDI \"VDI 2\".   This coalesced VDI, VDI 2, can be used to restore the state of the VDI on XenServer at the time that a snapshot was taken for backup 2.  When creating a coalesced VDI, ensure that you work with your VDIs and changed blocks as binary.  Ensure that you verify the integrity of the backed up and restored VDIs.\nFor example, you can do this by computing the checksums of the data.", 
            "title": "Coalescing changed blocks onto a base VDI"
        }, 
        {
            "location": "/coalescing-blocks/#examples", 
            "text": "The following example shows how to create a coalesced VDI.\nThe example shows applying a single set of changed blocks to the base VDI snapshot.\nTo apply multiple sets of changed blocks, you must repeat this process for each set of changed blocks in order from oldest to most recent, using the output from the  previous iteration as the base VDI for the next iteration.  Python:  def   write_changed_blocks_to_base_VDI ( vdi_path ,   changed_block_path ,   bitmap_path ,   output_path ): \n     bitmap   =   open ( bitmap_path ,   r ) \n     vdi   =   open ( vdi_path ,   r+b ) \n     blocks   =   open ( changed_block_path ,   r+b ) \n     combined_vdi   =   open ( output_path ,   wb ) \n\n     try : \n         bitmap_r   =   bitmap . read () \n         cb_offset   =   0 \n         for   x   in   range ( 0 ,   len ( bitmap_r )): \n             offset   =   x   *   changed_block_size \n             if   bitmap_r [ x ]   ==   1 : \n                 blocks . seek ( cb_offset ) \n                 blocks_r   =   blocks . read ( changed_block_size ) \n                 combined_vdi . write ( blocks_r ) \n                 cb_offset   +=   changed_block_size \n             else : \n                 vdi . seek ( offset ) \n                 vdi_r   =   vdi . read ( changed_block_size ) \n                 combined_vdi . write ( vdi_r )", 
            "title": "Examples"
        }, 
        {
            "location": "/appendices/", 
            "text": "Appendices\n\n\nConstraints\n\n\nThe following section lists advisories and constraints to consider when using changed block tracking.\n\n\n\n\n\n\nChanged block tracking is available only to customers with an Enterprise license for XenServer.\n    If a customer without an Enterprise license attempts to use an incremental backup solution for XenServer that uses changed block tracking, they are prevented from enabling changed block tracking on new VDIs.\n    However, if the customer has existing VDIs with changed block tracking enabled, they can still perform other changed block tracking actions on these VDIs.\n\n\n\n\n\n\nChanged block tracking information is lost on Storage XenMotion.\n    If you attempt to migrate a VM that has VDIs with changed block tracking enabled, you are prevented from doing so.\n    You must disable changed block tracking before Storage XenMotion is allowed.\n\n\n\n\n\n\nIf a host or an SR crashes, XenServer disables changed block tracking for all VDIs on that host or SR.\n    Before taking a VDI snapshot, we recommend that you check whether changed block tracking is enabled.\n    If changed block tracking is disabled and this is not expected, this can indicate that a crash has occurred or that a XenServer user has disabled changed block tracking.\n\n\nTo continue using changed block tracking, you must enable changed block tracking again and create a new baseline by taking a full VDI snapshot.\nSubsequent changed block tracking metadata uses this snapshot as a new baseline.\n\n\nThe set of snapshots and changed block tracking data captured before the crash cannot be used as a baseline or comparison for any snapshots taken after the crash.\nHowever, the set of incremental backups taken before the crash can be used to create a VDI image to use to restore the VDI to a previous state.\n\n\nFor more information, see \nIncremental backup sets\n.\n\n\n\n\n\n\nXenServer supports a maximum of 16 concurrent NBD connections.\n\n\n\n\n\n\nAdditional Resources\n\n\nThe following resources provide additional information:\n\n\n\n\n\n\nGitHub repository of sample code\n\n\n\n\n\n\nCitrix XenServer Management API Guide\n\n\n\n\n\n\nCitrix XenServer Software Development Kit Guide\n\n\n\n\n\n\nCitrix XenServer documentation\n\n\n\n\n\n\nNBD protocol documentation\n\n\n\n\n\n\nnbd-client manpage", 
            "title": "Appendices"
        }, 
        {
            "location": "/appendices/#appendices", 
            "text": "", 
            "title": "Appendices"
        }, 
        {
            "location": "/appendices/#constraints", 
            "text": "The following section lists advisories and constraints to consider when using changed block tracking.    Changed block tracking is available only to customers with an Enterprise license for XenServer.\n    If a customer without an Enterprise license attempts to use an incremental backup solution for XenServer that uses changed block tracking, they are prevented from enabling changed block tracking on new VDIs.\n    However, if the customer has existing VDIs with changed block tracking enabled, they can still perform other changed block tracking actions on these VDIs.    Changed block tracking information is lost on Storage XenMotion.\n    If you attempt to migrate a VM that has VDIs with changed block tracking enabled, you are prevented from doing so.\n    You must disable changed block tracking before Storage XenMotion is allowed.    If a host or an SR crashes, XenServer disables changed block tracking for all VDIs on that host or SR.\n    Before taking a VDI snapshot, we recommend that you check whether changed block tracking is enabled.\n    If changed block tracking is disabled and this is not expected, this can indicate that a crash has occurred or that a XenServer user has disabled changed block tracking.  To continue using changed block tracking, you must enable changed block tracking again and create a new baseline by taking a full VDI snapshot.\nSubsequent changed block tracking metadata uses this snapshot as a new baseline.  The set of snapshots and changed block tracking data captured before the crash cannot be used as a baseline or comparison for any snapshots taken after the crash.\nHowever, the set of incremental backups taken before the crash can be used to create a VDI image to use to restore the VDI to a previous state.  For more information, see  Incremental backup sets .    XenServer supports a maximum of 16 concurrent NBD connections.", 
            "title": "Constraints"
        }, 
        {
            "location": "/appendices/#additional-resources", 
            "text": "The following resources provide additional information:    GitHub repository of sample code    Citrix XenServer Management API Guide    Citrix XenServer Software Development Kit Guide    Citrix XenServer documentation    NBD protocol documentation    nbd-client manpage", 
            "title": "Additional Resources"
        }
    ]
}